function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function buildBaseNames(captureStartedAtIso) {
  const tsSlug = captureStartedAtIso.replace(/[:.]/g, '-');
  const eegBase = `sub-01_ses-01_task-meditrain_run-${tsSlug}_eeg`;
  const ppgBase = eegBase.replace('_eeg', '_ppg');
  return { eegBase, ppgBase };
}

export function exportBrainVision({
  activeEeg,
  windowSamples,
  sampleRateHz,
  lastTimestampMs,
  notchHz,
  downloadMetadata,
  ppgChannels,
  ppgSampleRateHz
}) {
  const samplePeriodMs = 1000 / sampleRateHz;
  const captureEndedAt = new Date(lastTimestampMs);
  const captureStartedAtIso = new Date(
    captureEndedAt.getTime() - Math.max(windowSamples - 1, 0) * samplePeriodMs
  ).toISOString();

  const { eegBase, ppgBase } = buildBaseNames(captureStartedAtIso);
  const dataFile = `${eegBase}.eeg`;
  const headerFile = `${eegBase}.vhdr`;
  const markerFile = `${eegBase}.vmrk`;
  const channelsFile = `${eegBase.replace('_eeg', '_channels')}.tsv`;
  const sidecarFile = `${eegBase}.json`;
  const ppgDataFile = `${ppgBase}.tsv`;
  const ppgSidecarFile = `${ppgBase}.json`;

  const channelLabels = activeEeg.map(c => c.label || c.electrode);
  const alignedSamples = activeEeg.map(c => c.samples.slice(-windowSamples));
  const channelCount = alignedSamples.length;
  const interleaved = new Float32Array(windowSamples * channelCount);
  for (let i = 0; i < windowSamples; i += 1) {
    for (let ch = 0; ch < channelCount; ch += 1) {
      interleaved[i * channelCount + ch] = alignedSamples[ch][i] || 0;
    }
  }

  const headerLines = [
    'Brain Vision Data Exchange Header File Version 1.0',
    '; Generated by meditrain',
    '',
    '[Common Infos]',
    `DataFile=${dataFile}`,
    `MarkerFile=${markerFile}`,
    'DataFormat=BINARY',
    'DataOrientation=MULTIPLEXED',
    'DataType=FLOAT32',
    `NumberOfChannels=${channelCount}`,
    `SamplingInterval=${Math.round(1000000 / sampleRateHz)}`,
    '',
    '[Channel Infos]',
    ...channelLabels.map((label, idx) => `Ch${idx + 1}=${label},,uV`)
  ];

  const markerLines = [
    'Brain Vision Data Exchange Marker File, Version 1.0',
    '; Generated by meditrain',
    '',
    '[Common Infos]',
    `DataFile=${dataFile}`,
    '',
    '[Marker Infos]',
    'Mk1=New Segment,,1,1,0,0'
  ];

  const sidecar = {
    SamplingFrequency: sampleRateHz,
    PowerLineFrequency: 60,
    EEGReference: 'unknown',
    EEGGround: 'unknown',
    SoftwareFilters: 'none',
    RecordingType: 'continuous',
    TaskName: 'meditrain',
    AcquisitionDateTime: captureStartedAtIso,
    NotchHz: notchHz
  };
  if (downloadMetadata) {
    sidecar.TrainingTargets = downloadMetadata.trainingTargets || [];
    sidecar.TrainingTargetMetrics = downloadMetadata.targetMetrics || {};
    sidecar.TrainingTargetHistory = downloadMetadata.targetHistory || {};
    sidecar.TrainingTargetReadings = downloadMetadata.targetReadings || [];
    sidecar.Config = downloadMetadata.config || {};
    if (downloadMetadata.telemetry) sidecar.Telemetry = downloadMetadata.telemetry;
    if (downloadMetadata.accelerometer) sidecar.Accelerometer = downloadMetadata.accelerometer;
    if (downloadMetadata.gyroscope) sidecar.Gyroscope = downloadMetadata.gyroscope;
    if (downloadMetadata.telemetryHistory) sidecar.TelemetryHistory = downloadMetadata.telemetryHistory;
    if (downloadMetadata.accelerometerHistory) sidecar.AccelerometerHistory = downloadMetadata.accelerometerHistory;
    if (downloadMetadata.gyroscopeHistory) sidecar.GyroscopeHistory = downloadMetadata.gyroscopeHistory;
    if (downloadMetadata.deviceInfo) sidecar.DeviceInfo = downloadMetadata.deviceInfo;
    if (downloadMetadata.ppgLabelMap) sidecar.PpgLabelMap = downloadMetadata.ppgLabelMap;
  }

  const channelHeader = [
    'name',
    'type',
    'units',
    'sampling_frequency',
    'low_cutoff',
    'high_cutoff',
    'reference'
  ].join('\t');
  const channelLines = channelLabels.map(label =>
    [
      label,
      'EEG',
      'uV',
      sampleRateHz,
      'n/a',
      'n/a',
      'unknown'
    ].join('\t')
  );

  triggerDownload(new Blob([interleaved.buffer], { type: 'application/octet-stream' }), dataFile);
  triggerDownload(new Blob([headerLines.join('\n')], { type: 'text/plain' }), headerFile);
  triggerDownload(new Blob([markerLines.join('\n')], { type: 'text/plain' }), markerFile);
  triggerDownload(new Blob([JSON.stringify(sidecar, null, 2)], { type: 'application/json' }), sidecarFile);
  triggerDownload(new Blob([[channelHeader, ...channelLines].join('\n')], { type: 'text/tab-separated-values' }), channelsFile);

  const ppgActive = (ppgChannels || []).filter(c => c && c.samples && c.samples.length > 0);
  if (ppgActive.length > 0) {
    const windowDurationSec = windowSamples / sampleRateHz;
    const ppgWindowSamples = Math.min(
      Math.round(windowDurationSec * ppgSampleRateHz),
      ...ppgActive.map(c => c.samples.length)
    );
    if (ppgWindowSamples > 0) {
      const ppgAligned = ppgActive.map(c => c.samples.slice(-ppgWindowSamples));
      const ppgHeader = ppgActive.map(c => c.label).join('\t');
      const ppgRows = [];
      for (let i = 0; i < ppgWindowSamples; i += 1) {
        ppgRows.push(ppgAligned.map(ch => ch[i] ?? '').join('\t'));
      }
      const ppgSidecar = {
        SamplingFrequency: ppgSampleRateHz,
        PowerLineFrequency: 60,
        RecordingType: 'continuous',
        TaskName: 'meditrain',
        AcquisitionDateTime: captureStartedAtIso,
        Columns: ppgActive.map(c => c.label)
      };
      triggerDownload(new Blob([[ppgHeader, ...ppgRows].join('\n')], { type: 'text/tab-separated-values' }), ppgDataFile);
      triggerDownload(new Blob([JSON.stringify(ppgSidecar, null, 2)], { type: 'application/json' }), ppgSidecarFile);
    }
  }

  return {
    captureStartedAtIso,
    windowSec: Math.floor(windowSamples / sampleRateHz)
  };
}

